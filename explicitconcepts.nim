#[
   explicitconcepts.nim
   
   Copyright 2017 Gerd Mathar

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
]#

## This module provides explicit concepts and an ``implements``-relation
## between concepts and implementing types.
##
## Motivation
## ==========
##
## A type satisfies a regular concept if it matches the requirements defined
## by the concept. This is an implicit match, the creator of the type did
## not declare intent to make the type satisfy the concept. While this is often
## useful, in other cases, stating an ``implements``-relation between the
## type and the concept in the source code to make the intention clear produces
## more readable and safer code: An explicit concept is only satisfied by a
## type if such an ``implements``-relation exists.
##
## Use
## ====
##
## .. code-block:: nim
##   implements C, ExC: X
## Defines ``implements``-relations for an existing type and existing concepts:
## ``X`` implements concepts ``C`` and ``ExC``.
##
## .. code-block:: nim
##   explicit:
##     type
##       ExD = concept d
##         d.x is float
## Defines an explicit concept ``ExD``.
##
## .. code-block:: nim
##   implements ExD:
##     type
##       Xx = object
##         x: float
##   
##       Y = object
##         x: float
##
##   type
##     Y2 = object
##       x: float
##
##   echo(Y is ExD)   # -> true
##   echo(Y2 is ExD)  # -> false
## Defines ``implements``-relations for new types: ``Xx`` and ``Y``
## implement concept ``ExD``. Note that, despite the fact that it fulfills
## the requirement in the body of ``ExD``, ``Y2`` does not satisfy ``ExD``
## because ``ExD`` is explicit and there is no ``implements``-relation
## defined between the two. 
##
## The ``implements``-relation between a type and a concept automatically
## extends to aliases of the two and to derivatives of the type, but not to
## distinct aliases of the two and to refinements of the concept.
##
## For details see the source files in the ``tests`` directory.

import strutils, macros

const
  magic = "9F08B7C91364CDF2"
  implFmt = "implements: $#"
  explFmt = "explicit: $#"

type
  ConceptInfo = tuple[sym, def: NimNode]
  ConceptId = string
  ConceptCompanion[id: static[ConceptId]] = distinct auto

proc`$`(cie: ConceptInfo): string =
  cie.def.lineInfo & "::" & cie.sym.treeRepr

proc conceptInfo(ci: ConceptInfo): ConceptInfo =
  var ti = getImpl(ci.def.symbol)

  if not ti.findChild(nnkBracketExpr == it.kind).isNil:
    error(implFmt % "generic concepts are not yet supported.", ci.sym)

  case ti[2].kind
  of nnkSym:
    # type alias: query original symbol and definition instead.
    (ti[2], ti[2]).conceptInfo
  of nnkDistinctTy:
    # distinct type: keep original distinct name, resolve original type.
    (ci.sym, (ci.sym, ti[2][0]).conceptInfo.def)
  of nnkTypeClassTy:  # actual concept definition: return it.
    (ci.sym, ti)
  else:
    error(implFmt % "concept expected.", ci.sym)
    (nil, nil)

proc conceptInfo(c: NimNode): ConceptInfo =
  # Returns a tuple containing the resolved actual symbol and definition nodes
  # of the passed concept symbol node.
  (c, c).conceptInfo

proc toId(ci: ConceptInfo): ConceptId =
  $ci

proc id(c: NimNode): ConceptId =
  c.conceptInfo.toId

template implProcCall(c, t: untyped): untyped =
  implementedBy9F08B7C91364CDF2(c, t)

template flagProcDef(t: untyped, cid: ConceptId): untyped =
  var m = magic

  # The existence of this proc signals an ``implemements``-relation.
  proc `impl m`*(Ty: typedesc[t], Co: typedesc[ConceptCompanion[cid]])
    {.compileTime.} = discard

template flagProcCall(t: untyped, cid: ConceptId): untyped =
  var m = magic
  `impl m`(t, ConceptCompanion[cid])

macro checkImplements*(t, c: typed): untyped =
  ## Produces the code to check wether there is an ``implemements``-relation
  ## between the type and the concept bound to the passed symbol nodes ``t``
  ## and ``c``, respectively.
  newStmtList(newCall("compiles", getAst flagProcCall(t, c.id)))

proc standIn(sym, def: NimNode): NimNode =
  # Analyzes an AST generated by ``explConcDef`` to find the symbol node
  # bound to the stand-in concept.
  result = def.findChild(nnkTypeClassTy == it.kind)
  if not result.isNil:
    result = result.findChild(nnkStmtList == it.kind)
    if not result.isNil and result.len > 0:
      var lst = result.last
      result = nil
      if nnkCall == lst.kind:
        if "checkImplements" == $lst[0].symbol:
          lst = lst.last
          if $sym.symbol & magic == $lst.symbol:
            result = lst

template explConcDef(co, standIn: untyped): untyped =
  type co = concept c, type T
    c is standIn
    checkImplements(T, standIn)

template procDef(cid: ConceptId, t: typed, warn: bool): untyped =
  when compiles(flagProcCall(t, cid)):
    when warn:
      {.warning: implFmt % "redundant statement is ignored.".}
  else:
    flagProcDef(t, cid)

macro implementedBy9F08B7C91364CDF2*(c, t: typed): typed =
  ## Establishes an ``implements``-relation between the type and the
  ## concept given by the symbol nodes ``t`` and ``c``, respectively.
  var
    ci = c.conceptInfo
    standInConc = standIn(c, ci.def)

  result = newStmtList()
  result.add getAst procDef(ci.toId, t, true)
  if standInConc.isNil:
    warning implFmt %
      $c.symbol & " is not explicit, the implements-relation will not" &
      " be checked on use of implementing type."
  else:
    result.add getAst procDef(standInConc.id, t, false)

template checkMatch(c, t: untyped): untyped =
  when not(t is c):
    {.fatal: explFmt % "concept not satisfied.".}

proc implStmts(args, t: NimNode): NimNode =
  result = newStmtList()
  for c in args:
    if c.kind in {nnkStmtList}:
      break
    result.add getAst implProcCall(c, t)
    result.add getAst checkMatch(c, t)

macro implements*(args: varargs[untyped]): untyped =
  ## Establishes an ``implements``-relation between concepts given
  ## as leading arguments and an existing type or the types defined in type
  ## sections given as a trailing block argument.
  result = newStmtList()
  args.expectKind(nnkArglist)
  if args.len == 0 or nnkStmtList == args[0].kind:
    error(implFmt % "implemented concepts expected.", args)
  var stmts = args.findChild(nnkStmtList == it.kind)
  if isNil(stmts) or stmts.len == 0:
    error(implFmt % "implementing type or type sections expected.", args)
  if stmts.len == 1 and nnkTypeSection != stmts[0].kind:
    result.add implStmts(args, stmts[0])
  else:
    for ts in stmts:
      ts.expectKind(nnkTypeSection)
      result.add ts
      for td in ts:
        result.add implStmts(args, td[0])

template checkConceptCall(c: untyped): untyped =
  checkConcept9F08B7C91364CDF2(c)

macro explicit*(args: untyped): untyped =
  ## Makes the concepts defined in the type sections passed as a block argument
  ## explicit.
  args.expectKind(nnkStmtList)
  if args.len == 0:
    error(explFmt % "concept definitions expected.", args)
  result = args
  for ts in result:
    ts.expectKind(nnkTypeSection)
    var i = 0
    while i < ts.len:
      var td = ts[i]

      if nnkIdent == td.last.kind:
        error(explFmt % "concept aliases cannot be explicit.", args)

      var scd = td[0].copy
      td[0].basename = $td[0].basename & magic
      i.inc
      ts.insert(i, getAst(explConcDef(scd, td[0].basename))[0][0])
      i.inc

      # TODO: implemement concept check
      #result.add getAst checkConceptAst(td[0].basename)
